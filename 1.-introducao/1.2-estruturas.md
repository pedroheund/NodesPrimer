---
description: Come√ßando pelo come√ßo!üìù
---

# 1.2 Programa√ß√£o visual

### A abordagem visual:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### A abordagem textual:

1. Comece com a ponta larga da gravata √† direita e a ponta estreita √† esquerda. A ponta estreita deve ficar ligeiramente acima do seu umbigo. Lembre-se de que voc√™ s√≥ vai mover a ponta larga durante o processo.
2. Cruze a ponta larga sobre a ponta estreita, indo da direita para a esquerda.
3. Leve a [ponta ](#user-content-fn-1)[^1]larga para cima e passe por baixo do la√ßo no pesco√ßo.
4. Des√ßa a ponta larga para a esquerda.
5. Passe a ponta larga por tr√°s da ponta estreita, indo da esquerda para a direita.
6. Suba novamente a ponta larga para o centro, em dire√ß√£o ao la√ßo no pesco√ßo.
7. Passe a ponta larga por dentro do la√ßo no pesco√ßo e des√ßa para a direita.
8. Cruze a ponta larga na frente da gravata para a esquerda.
9. Suba a ponta larga novamente, passando por baixo do la√ßo no pesco√ßo.
10. Des√ßa a ponta larga pelo la√ßo que voc√™ acabou de criar na frente.
11. Aperte o n√≥ puxando a ponta larga. Ajuste o n√≥ subindo e arrumando para que ele fique bem firme e sim√©trico.

### A abordagem do aprendizado

Aprender algo novo fica muito mais f√°cil quando conseguimos ver o processo acontecendo. Um exemplo disso √© dar um n√≥ na gravata. Eu, por exemplo, nunca conseguiria fazer isso s√≥ lendo as instru√ß√µes. Se eu tentasse seguir apenas as palavras, acabaria com um n√≥ completamente torto. Mas, ao ver os movimentos passo a passo, tudo fica muito mais claro e menos complicado. Visualizar a a√ß√£o torna uma tarefa que parecia dif√≠cil algo simples e acess√≠vel, especialmente no primeiro contato com algo novo.

***

### No code, low code e afins

Provavelmente voc√™ j√° deve ter ouvido os termos "low code" ou "no code". Esses termos se referem a uma linguagem de programa√ß√£o visual que permite criar programas conectando blocos gr√°ficos em vez de escrever c√≥digo. Em vez de digitar comandos, voc√™ constr√≥i sua l√≥gica arrastando e ligando elementos visuais que representam opera√ß√µes e dados.

Esse tipo de abordagem √© ideal para quem quer focar na l√≥gica e na solu√ß√£o dos problemas, sem se preocupar com detalhes t√©cnicos.

Al√©m disso, a programa√ß√£o visual √© extremamente intuitiva, tornando-se uma excelente porta de entrada para quem nunca programou antes. Como tudo √© representado visualmente, fica mais f√°cil entender o fluxo de informa√ß√µes.

***

### Construindo um c√≠rculo no Eberick

* Manualmente:

<figure><img src="../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

> 1. Escolher o n√≠vel
> 2. Clicar no comando C√≠rculo&#x20;
> 3. Clicar no ponto do centro&#x20;
> 4. Clicar no ponto tangente
> 5. Acessar as propriedades do c√≠rculo

***

* Automatizando com o Nodes:

<figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

> 1. Informar o centro do c√≠rculo atrav√©s do n√≥ "Ponto", criado com as entradas x e y, preenchidas pelos valores do n√≥ "N√∫mero".
> 2. Informar o raio do c√≠rculo, utilizando um n√≥ "N√∫mero".&#x20;
> 3. Escolher o n√≠vel do desenho com um n√≥ de sele√ß√£o chamado "N√≠vel".&#x20;
> 4. Informar se o c√≠rculo ser√° preenchido (verdadeiro) ou n√£o (falso) com um n√≥ "Booleano".

***

### Textual x visual

Imaginando que existisse uma linguagem textual capaz de realizar a mesma automa√ß√£o de gerar o desenho de um circulo, podemos abstrair e imaginar que o algoritmo abaixo seria o correto para obter o mesmo desenho:&#x20;

```lua
    pontoCentral ‚Üê criarPonto(0.0, 0.0)
    raio ‚Üê 10.0
    nivelEscolhido ‚Üê nivel(Detalhes)
    preenchido ‚Üê falso
    criarCirculo(pontoCentral, raio, nivelEscolhido, preenchido)
```

Repare que no c√≥digo textual voc√™ precisa conhecer e seguir as regras da linguagem para que o computador entenda o que voc√™ quer que ele fa√ßa. Em termos simples:

* **Atribui√ß√£o de valores:** Quando voc√™ escreve `raio ‚Üê 10.0`, por exemplo, voc√™ est√° dizendo ao computador que a vari√°vel `raio` vai ter o valor `10.0`. Isso tem que ser feito de acordo com uma regra espec√≠fica da linguagem de programa√ß√£o (neste caso, o s√≠mbolo `‚Üê` para atribui√ß√£o).
* **Fun√ß√µes e m√©todos:** Quando usamos algo como `criarPonto(0.0, 0.0)`, voc√™ precisa saber o nome da fun√ß√£o (neste caso, `criarPonto`) e os argumentos que ela aceita (no caso, dois n√∫meros, representando as coordenadas `x` e `y`). Voc√™ n√£o pode inventar o nome de uma fun√ß√£o ou colocar um valor errado; isso tem que ser feito de forma exata, do jeito que a linguagem espera.
* **Sintaxe**: O c√≥digo precisa ter a sintaxe correta, ou seja, a forma como voc√™ escreve √© essencial. Diferente de uma linguagem gramatical, onde as pessoas podem entender mesmo que voc√™ escreva algo errado, na linguagem de c√≥digo, se a sintaxe n√£o for seguida corretamente, o computador n√£o entender√° o que voc√™ quer fazer.



J√° no c√≥digo visual voc√™ se preocupa apenas com a constru√ß√£o do seu fluxo. Ou seja:&#x20;

* **Conectar blocos:** Em vez de escrever c√≥digo, voc√™ arrasta e solta blocos para criar o que deseja. Cada bloco representa uma a√ß√£o espec√≠fica (como "criar ponto", "desenhar c√≠rculo" etc.).
* **Argumentos de fun√ß√µes:** Nos blocos, n√£o √© preciso saber exatamente como se chama a fun√ß√£o ou quais s√£o os par√¢metros exatos. Voc√™ s√≥ conecta os blocos certos e o sistema sabe o que fazer.
* **Simples e direto:** N√£o h√° a preocupa√ß√£o com sintaxe, como colocar ponto e v√≠rgula ou chaves para delimitar o c√≥digo. Tudo √© visual, e voc√™ s√≥ se preocupa em conectar os blocos certos, algo muito mais f√°cil para quem n√£o est√° acostumado com a programa√ß√£o.

***

### Por que come√ßar pela programa√ß√£o visual?&#x20;

* **F√°cil de aprender** ‚Äì Ideal para quem nunca programou antes, pois permite entender a l√≥gica sem barreiras t√©cnicas.
* **Visual e intuitivo** ‚Äì Em vez de ler linhas de c√≥digo, voc√™ v√™ o fluxo de informa√ß√µes se formando diante dos seus olhos.
* **Menos erros, mais produtividade** ‚Äì Como tudo √© modular e conectado visualmente, fica mais f√°cil identificar e corrigir problemas.
* **Automa√ß√£o sem complica√ß√£o** ‚Äì Crie processos personalizados para suas necessidades.
* **Mais foco na solu√ß√£o** ‚Äì Voc√™ se concentra no que realmente importa: resolver problemas e otimizar seu fluxo de trabalho.



[^1]: 
